---
title: 'Proxygen source code review (3)'
date: 2020-06-03
permalink: /blog/2020/06/Proxygen-note3/
tags:
  - Proxygen
---

# Proxygen source code review (3)
This is the third section of Proxygen source code review.

## Handle a HTTP request
When a new HTTP request is read in, Proxygen uses an external HTTP parser library to parse it, and save it as a `HTTPMessage` object. The HTTP parser it uses is based on the parser used by Nginx.

`HTTPCodec` implements the callback functions defined in the http parser library. `onIngress()` is the first function of `HTTPCodec` to be called. It starts parsing the message by 
```
size_t bytesParsed = http_parser_execute(&parser_,
                                             getParserSettings(),
                                             (const char*)buf.data(),
                                             buf.length());
```
Callback functions are set in `getParserSettings()`, and those functions are called when `http_parser_execute()` is called. Please be sure that all of the callback functions should return 0 when successed and return 1 when failed. Unexpected errors might happen if the return values are misdefined.
```
const http_parser_settings* HTTP1xCodec::getParserSettings() {
  static http_parser_settings parserSettings = [] {
    http_parser_settings st;
    st.on_message_begin = HTTP1xCodec::onMessageBeginCB;
    st.on_url = HTTP1xCodec::onUrlCB;
    st.on_header_field = HTTP1xCodec::onHeaderFieldCB;
    st.on_header_value = HTTP1xCodec::onHeaderValueCB;
    st.on_headers_complete = HTTP1xCodec::onHeadersCompleteCB;
    st.on_body = HTTP1xCodec::onBodyCB;
    st.on_message_complete = HTTP1xCodec::onMessageCompleteCB;
    st.on_reason = HTTP1xCodec::onReasonCB;
    st.on_chunk_header = HTTP1xCodec::onChunkHeaderCB;
    st.on_chunk_complete = HTTP1xCodec::onChunkCompleteCB;
    return st;
  }();
  return &parserSettings;
}
```

The functions `on...()` in `HTTPSession` will also be called in the functions of `HTTPCodec`. The diagram is as followed:
```
HTTP1xCodec::onHeadersComplete() -> HTTPSession::onHeadersComplete() -> HTTPDownstreamSession::setupOnHeadersComplete()
```

In `HTTPSession`, a new controller is allocated by calling `HTTPSessionBase::getController()`. In `HTTPDownstreamSession`, a new handler is created by the controller, by calling `acceptor_ -> newHandler()`, and is attached to a `HTTPTransaction` by calling 
```
handler = SimpleController::getRequestHandler();
Transaction -> setHandler(handler);
```

In `newHandler()` of `HTTPServerAcceptor`, each `HandlerFactory`'s `onRequest()` will be called, and a new `RequestHandlerAdaptor` is returned;
```
HTTPTransactionHandler* HTTPServerAcceptor::newHandler(
    HTTPTransaction& txn,
    HTTPMessage* msg) noexcept {

  SocketAddress clientAddr, vipAddr;
  txn.getPeerAddress(clientAddr);
  txn.getLocalAddress(vipAddr);
  msg->setClientAddress(clientAddr);
  msg->setDstAddress(vipAddr);

  // Create filters chain
  RequestHandler* h = nullptr;
  for (auto& factory: handlerFactories_) {
    h = factory->onRequest(h, msg);
  }

  return new RequestHandlerAdaptor(h);
}
```

`RequestHandlerAdaptor` will interact with `ResponseHandler` and send responses to clients.