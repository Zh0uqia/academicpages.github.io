---
title: 'Proxygen source code review (2)'
date: 2020-06-03
permalink: /blog/2020/06/Proxygen-note2/
tags:
  - Proxygen
---

# Proxygen source code review (2)
This is the second section of Proxygen source code review.

## Overview of Proxygen architecture
The architecture of Proxygen is as [this picture](https://github.com/facebook/proxygen/blob/master/CoreProxygenArchitecture.png) in its official README shows. A complete diagram of how it processes a http request is in `HTTPTransaction.h`:
```
/**
 * An HTTPTransaction represents a single request/response pair
 * for some HTTP-like protocol.  It works with a Transport that
 * performs the network processing and wire-protocol formatting
 * and a Handler that implements some sort of application logic.
 *
 * The typical sequence of events for a simple application is:
 *
 *   * The application accepts a connection and creates a Transport.
 *   * The Transport reads from the connection, parses whatever
 *     protocol the client is speaking, and creates a Transaction
 *     to represent the first request.
 *   * Once the Transport has received the full request headers,
 *     it creates a Handler, plugs the handler into the Transaction,
 *     and calls the Transaction's onIngressHeadersComplete() method.
 *   * The Transaction calls the Handler's onHeadersComplete() method
 *     and the Handler begins processing the request.
 *   * If there is a request body, the Transport streams it through
 *     the Transaction to the Handler.                               
 *   * When the Handler is ready to produce a response, it streams
 *     the response through the Transaction to the Transport.
 *   * When the Transaction has seen the end of both the request
 *     and the response, it detaches itself from the Handler and
 *     Transport and deletes itself.
 *   * The Handler deletes itself at some point after the Transaction
 *     has detached from it.
 *   * The Transport may, depending on the protocol, process other
 *     requests after -- or even in parallel with -- that first
 *     request.  Each request gets its own Transaction and Handler.
 *
 * For some applications, like proxying, a Handler implementation
 * may obtain one or more upstream connections, each represented
 * by another Transport, and create outgoing requests on the upstream
 * connection(s), with each request represented as a new Transaction.
 *
 * With a multiplexing protocol like SPDY on both sides of a proxy,
 * the cardinality relationship can be:
 *
 *                 +-----------+     +-----------+     +-------+
 *   (Client-side) | Transport |1---*|Transaction|1---1|Handler|
 *                 +-----------+     +-----------+     +-------+
 *                                                         1
 *                                                         |
 *                                                         |
 *                                                         1
 *                                   +---------+     +-----------+
 *                (Server-side)      |Transport|1---*|Transaction|
 *                                   +---------+     +-----------+
 *
 * A key design goal of HTTPTransaction is to serve as a protocol-
 * independent abstraction that insulates Handlers from the semantics
 * different of HTTP-like protocols.
 */
```


## From starting listening to new connections coming in

In last section, I introduced several components to build a simple http server using Proxygen. I would like to explain what is happening behind those interfaces from starting listening to accepting new connections.

In the `main` function, we can configure our options and pass it into server. `options` has a list of `HandlerFactory` that can handle different events.
```
options.handlerFactories = RequestHandlerChain()
      .addThen<StaticHandlerFactory>()
      .build();
```

`AcceptorFactory` accepts `HandlerFactory` as the parameter of its constructor.
```
// AcceptorFactory
auto factory = std::make_shared<AcceptorFactory>(
          options_, // include HandlerFactory
          codecFactory,
          accConfig,
          sessionInfoCb_);
```

Then a `bootstrap` is started. `bootstrap` is in the `wangle` library. What `bootstrap` does here are mainly completed by three functions:
```
bootstrap_[i].childHandler(factory);
bootstrap_[i].group(accExe, exe); 
bootstrap_[i].bind(addresses_[i].address);
```

`bootstrap.group()` sets the thread pool for acception and IO. In `group()`, `AcceptorFactory` will new an acceptor and binds it with a new thread pool through `newAcceptor(eventBase)` in `wangle::threadStarted()`.

In `bind()`, new `asynServerSocket` is built by `newSocket()` of `socketFactory`. Asynchronous callback function for accepting new connections is binded with `asynServerSocket`, and thread is set with it:
```
socketFactory -> addAcceptCB(socket, worker, worker -> getEventBase());
```

After a new connection coming in, `acceptCB()` will be called and several functions in `wangle` will be executed. The last function is `onNewConnection()` in `HTTPServerAcceptor`.

In Proxygen, `HTTPServerAcceptor::onNewConnection()` will call `HTTPSessionAcceptor::onNewConnection()`. In this function, new session is started:
```
session -> setSessionStats(downStreamSessionStats_);
Acceptor::addConnection(session);
session -> StartNow();
```
